#
#   NAIF PDS4 Bundle Generator (naif-pds4-bundle)
#
#   -------------------------------------------------------------------------
#   @author: Marc Costa Sitja (JPL)
#
#   THIS SOFTWARE AND ANY RELATED MATERIALS WERE CREATED BY THE
#   CALIFORNIA INSTITUTE OF TECHNOLOGY (CALTECH) UNDER A U.S.
#   GOVERNMENT CONTRACT WITH THE NATIONAL AERONAUTICS AND SPACE
#   ADMINISTRATION (NASA). THE SOFTWARE IS TECHNOLOGY AND SOFTWARE
#   PUBLICLY AVAILABLE UNDER U.S. EXPORT LAWS AND IS PROVIDED "AS-IS"
#   TO THE RECIPIENT WITHOUT WARRANTY OF ANY KIND, INCLUDING ANY
#   WARRANTIES OF PERFORMANCE OR MERCHANTABILITY OR FITNESS FOR A
#   PARTICULAR USE OR PURPOSE (AS SET FORTH IN UNITED STATES UCC
#   SECTIONS 2312-2313) OR FOR ANY PURPOSE WHATSOEVER, FOR THE
#   SOFTWARE AND RELATED MATERIALS, HOWEVER USED.
#
#   IN NO EVENT SHALL CALTECH, ITS JET PROPULSION LABORATORY, OR NASA
#   BE LIABLE FOR ANY DAMAGES AND/OR COSTS, INCLUDING, BUT NOT
#   LIMITED TO, INCIDENTAL OR CONSEQUENTIAL DAMAGES OF ANY KIND,
#   INCLUDING ECONOMIC DAMAGE OR INJURY TO PROPERTY AND LOST PROFITS,
#   REGARDLESS OF WHETHER CALTECH, JPL, OR NASA BE ADVISED, HAVE
#   REASON TO KNOW, OR, IN FACT, SHALL KNOW OF THE POSSIBILITY.
#
#   RECIPIENT BEARS ALL RISK RELATING TO QUALITY AND PERFORMANCE OF
#   THE SOFTWARE AND ANY RELATED MATERIALS, AND AGREES TO INDEMNIFY
#   CALTECH AND NASA FOR ALL THIRD-PARTY CLAIMS RESULTING FROM THE
#   ACTIONS OF RECIPIENT IN THE USE OF THE SOFTWARE.
#   -------------------------------------------------------------------------
"""
The NAIF PDS4 Bundle Generator (naif-pds4-bundle) is a a pipeline that
generates a PDS4 SPICE archive bundle or a PDS3 SPICE archive data set. 

Using naif-pds4-bundle
----------------------
::

  usage: naif-pds4-bundle [-h] [-p PLAN] [-f FAUCET] [-l] [-s] [-v] [-d DIFF] 
                          [-c CLEAR] [-k KERLIST] CONFIG [CONFIG ...]
  
  naif-pds4-bundle-0.12.0, NAIF PDS4 SPICE archive generation pipeline 
  
    naif-pds4-bundle is a command-line utility program that generates PDS4 
    bundles and PDS3 data sets for SPICE archives.
  
  positional arguments:
    CONFIG                XML Configuration file
  
  optional arguments:
    -h, --help            show this help message and exit
    -p PLAN, --plan PLAN  Release plan file listing the kernels to be archived. 
                          If this argument is not provided, all the kernels 
                          found  in the kernels directory specified in the 
                          configuration file in addition to new meta-kernels 
                          will be included in the increment.
    -f FAUCET, --faucet FAUCET
                          Optional indication for end point of the pipeline. 
                          Allowed values are: 'plan; 'list', 'staging', or 
                          'final'.
    -l, --log             Write log in file
    -s, --silent          Log will not be prompted on the terminal during 
                          execution.
    -v, --verbose         Full log will be prompted on the terminal during 
                          execution. If argument is set to True, silent argument 
                          is omitted.
    -d DIFF, --diff DIFF  Optional generation of diff reports for products. 
                          Allowed values are: `all', `log', or `files'.
    -c CLEAR, --clear CLEAR
                          Clears the files listed in the input file from the 
                          staging and final areas and the kernel list from the 
                          working area. The inputfile should be as generated by 
                          a prior execution with a *.file_list extension. This 
                          argument does not start the pipeline afterwards. If 
                          this argument is provided it overwrites the faucet 
                          argument to 'plan'
    -k KERLIST, --kerlist KERLIST
                          Release plan file listing the kernels to be archived 
                          along with some parameters required for the run. 
                          If this argument isprovided the release plan is not 
                          generated.
  
"""
import naif_pds4_bundle
from textwrap import dedent
from os.path import isdir
from os.path import dirname
from argparse import ArgumentParser, RawDescriptionHelpFormatter
from naif_pds4_bundle.classes.setup import Setup
from naif_pds4_bundle.classes.log import Log
from naif_pds4_bundle.classes.list import KernelList
from naif_pds4_bundle.classes.bundle import Bundle
from naif_pds4_bundle.classes.collection import SpiceKernelsCollection
from naif_pds4_bundle.classes.product import SpiceKernelProduct
from naif_pds4_bundle.classes.product import OrbnumFileProduct
from naif_pds4_bundle.classes.product import MetaKernelProduct
from naif_pds4_bundle.classes.product import InventoryProduct
from naif_pds4_bundle.classes.collection import DocumentCollection
from naif_pds4_bundle.classes.collection import MiscellaneousCollection
from naif_pds4_bundle.classes.product import SpicedsProduct
from naif_pds4_bundle.classes.product import ChecksumProduct
from naif_pds4_bundle.classes.object import Object


def main(config=False, plan=False, faucet='', log=False, silent=False, 
         verbose=False, diff='', debug=True, clear='', kerlist=''):
    """
    Main routine for the NAIF PDS4 Bundle Generator (naif-pds4-bundle).
    This routine gets the command line arguments or the parameter
    arbuments and runs the archive generation pipeline.

    :param config: XML Configuration file
    :param plan: Release plan file listing the kernels to be archived.
                 If this argument is not provided, all the kernels found in
                 the kernels directory specified in the configuration file
                 in addition to new meta-kernels will be included in the
                 increment
    :type plan: str 
    :param faucet: Optional indication for end point of the pipeline.
                   Allowed values are: `list', `staging', or `final'
    :type faucet: str
    :param log: Write log in file
    :type log: bool
    :param silent: Log will not be prompted on the terminal during execution
    :type silent: bool
    :param verbose: Full log will be prompted on the terminal  during
                    execution. If argument is set to True, silent argument
                    is omitted
    :type verbose: bool
    :param diff: Optional generation of diff reports for products. Allowed
                 values are: `all', `log', or `files'
    :type diff: str
    :param debug: Indicate whether if the pipeline is running in debug mode.
                  If so the format of the logging is different and the files
                  generated in a failed run are not cleaned up.
    :type debug: bool
    :param clear: Indicates if the pipeline will run only to clear previous
    run and specifies the file that indicates the files to be cleared.
    :type clear: str    
    :param kerlist: Release list file listing the kernels to be archived along
                 with their description.
    :type kerlist: str       
    """
    #
    # Load the naif-pds4-bundle version 
    #
    version = naif_pds4_bundle.__version__

    #
    # Determine whether if the pipeline is being executed directly from
    # the command line of called by another Python function. If this is
    # not the case, then the arguments are taken from the command line.
    #
    if not config and not plan:

        header = dedent(
            f'''\
    
    naif-pds4-bundle-{version}, NAIF PDS4 SPICE archive generation pipeline 
    
      naif-pds4-bundle is a command-line utility program that generates PDS4 
      bundles and PDS3 data sets for SPICE archives.
        ''')

        #
        # Build the argument parser.
        #
        parser = ArgumentParser(formatter_class=RawDescriptionHelpFormatter,
                                description=header)
        parser.add_argument('config', metavar='CONFIG', type=str, nargs='+',
                            help='XML Configuration file')
        parser.add_argument('-p', '--plan',
                            action='store', type=str,
                            help="Release plan file listing the kernels to "
                                 "be archived. If this argument is not "
                                 "provided, all the kernels found in the "
                                 "kernels directory specified in the "
                                 "configuration file in addition to new "
                                 "meta-kernels will be included in the "
                                 "increment.")
        parser.add_argument('-f', '--faucet',
                            default='',
                            action='store', type=str,
                            help="Optional indication for end point of the "
                                 "pipeline. Allowed values are: 'plan; 'list', "
                                 "'staging', or 'final'.")
        parser.add_argument('-l', '--log',
                            help='Write log in file',
                            action='store_true')
        parser.add_argument('-s', '--silent',
                            help="Log will not be prompted on the terminal "
                                 "during execution.",
                            action='store_true')
        parser.add_argument('-v', '--verbose',
                            help="Full log will be prompted on the terminal "
                                 "during execution. If argument is set to "
                                 "True, silent argument is omitted.",
                            action='store_true')
        parser.add_argument('-d', '--diff',
                            default='',
                            action='store', type=str,
                            help="Optional generation of diff reports for "
                                 "products. Allowed values are: `all', "
                                 "`log', or `files'.")
        parser.add_argument('-c', '--clear',
                            default='',
                            action='store', type=str,
                            help="Clears the files listed in the input file "
                                 "from the staging and final areas and the "
                                 "kernel list from the working area. The input "
                                 "file should be as generated by a prior "
                                 "execution with a *.file_list extension. "
                                 "If this argument is provided "
                                 "it overwrites the faucet argument to 'plan' "
                                 "and therefore the pipeline is not exectued. "
                                 "If you provide the adequate 'faucet', the"
                                 "pipeline will be executed until indicated.")
        parser.add_argument('-k', '--kerlist',
                            action='store', type=str,
                            help="Release plan file listing the kernels to "
                                 "be archived along with some parameters "
                                 "required for the run. If this argument is"
                                 "provided the release plan is not generated.")

        #
        # Store the arguments in the args object.
        #
        args = parser.parse_args()
        args.config = args.config[0]
        
        #
        # When executing from the command line, debug mode is not available.
        #
        args.debug = False

    #
    # If NPB is not executed from the command line then an args object is
    # initialised and the argument attributes are obtained from the
    # main function argument list.
    #
    else:
        args = Object()
        args.config = config
        args.plan = plan
        args.faucet = faucet
        args.log = log
        args.silent = silent
        args.verbose = verbose
        args.diff = diff
        args.debug = debug
        args.clear = clear
        args.kerlist = kerlist

    #
    # Turn lowercase or uppercase arguments that need it.
    #
    args.faucet = args.faucet.lower()
    args.diff = args.diff.lower()

    #
    # Set silent to False if verbose is set to True.
    #
    if args.verbose:
        args.silent = False

    #
    # Set faucet to plan if clear is provided.
    #
    if args.clear and not args.faucet:
        args.faucet = 'plan'

    #
    # Check if string optional parameters are correct.
    #
    if args.diff not in ['all', 'log', 'files', '']:
        raise Exception('-d, --diff argument has incorrect value.')
    if args.faucet not in ['plan', 'list', 'staging', 'final', '']:
        raise Exception('-f, --faucet argument has incorrect value.')

    #
    # The pipeline is executed now
    #
    # -- Generate setup object
    #
    #    * This object will be used by all the other objects
    #    * Parse JSON into an object with attributes corresponding
    #      to dict keys.
    #
    setup = Setup(args, version)

    #
    # -- Setup the logging
    #
    #    * The log will always be displayed on screen unless the silent
    #      option is chosen.
    #    * The log file will be written in the working directory
    #
    log = Log(setup, args)

    #
    #  -- Start the pipeline
    #
    log.start()

    #
    # Add the log to the setup object with the sole purpose for the log
    # to be accessible via setup to be able to write the product list file
    # for an interrupted run.
    #
    setup.log = log

    #
    # With the log started we check the current configuration
    #
    setup.check_configuration()

    #
    # -- Check the existence of a previous release
    #
    setup.set_release()

    #
    # -- Generate the kernel list object
    #
    #    * The kernel list object will generate the kernel list
    #      non-archival product.
    #
    list = KernelList(setup)

    #
    # If a plan file is provided it is processed otherwise a plan is
    # generated from the kernels directory.
    #
    if not args.kerlist:
        if not args.plan:
            list.write_plan()
        else:
            list.read_plan(args.plan)
        
    #
    # If the pipeline is running to clean-up a previous run, the action
    # is performed at this point.
    #
    if args.clear:
        setup.clear_run()        
        
    if setup.faucet == 'plan':
        log.stop()
        return
    
    if not args.kerlist:
        list.write_list()
    else:
        list.read_list(args.kerlist)
    
    #
    #    * Escape if the sole purpose of the execution is to generate
    #      the kernel list.
    #
    if setup.faucet == 'list':
        log.stop()
        return

    #
    # -- Generate the PDS4 bundle or PDS3 data set structure.
    #
    bundle = Bundle(setup)

    #
    # -- Load LSK, FK and SCLK kernels for coverage computations
    #
    setup.load_kernels()

    #
    # -- Initialise the SPICE kernels collection.
    #
    spice_kernels_collection = SpiceKernelsCollection(setup, bundle, list)

    #
    # -- Initialise the miscellaneous collection
    #
    miscellaneous_collection = MiscellaneousCollection(setup, bundle ,list)

    #
    # -- Populate the SPICE kernels collection from the kernels in
    #    the Kernel list
    #
    for kernel in list.kernel_list:
        #
        # * Each label is validated after generation.
        #
        if ('.nrb' in kernel.lower()) or  ('.orb' in kernel.lower()):
            #
            # The OrbnumFileProduct has to be provided the kernels collection
            # because it might require to update the kernel list if the
            # orbnum file name is updated.
            #
            miscellaneous_collection.add(
                OrbnumFileProduct(setup, kernel, miscellaneous_collection,
                                  spice_kernels_collection))
        elif not '.tm' in kernel.lower():
            spice_kernels_collection.add(
                SpiceKernelProduct(setup, kernel, spice_kernels_collection))

    #
    # -- Generate the meta-kernel(s).
    #
    (meta_kernels, user_input) = \
        spice_kernels_collection.determine_meta_kernels()
    if meta_kernels:
        for mk in meta_kernels:
            meta_kernel = MetaKernelProduct(setup, mk, spice_kernels_collection,
                                            user_input=user_input)
            spice_kernels_collection.add(meta_kernel)

    #
    # -- Set the increment times
    #
    spice_kernels_collection.set_increment_times()
    spice_kernels_collection.set_collection_vid()
    
    #
    # -- Validate the SPICE Kernels collection:
    #
    #    * Note the validation of products is performed after writing the
    #      product itself and therefore it is not explicitely executed
    #      from the main function.
    #
    #    * Check that there is a XML label for each file under spice_kernels.
    #      That is, we are validating the spice_kernel_collection.
    #
    spice_kernels_collection.validate()

    #
    # -- Generate the SPICE kernels collection inventory product (if the
    #    collection has been updated.)
    #
    if spice_kernels_collection.updated:
        
        spice_kernels_collection.set_collection_vid()
        spice_kernels_collection_inventory = InventoryProduct(setup,
                                             spice_kernels_collection)
        spice_kernels_collection.add(spice_kernels_collection_inventory)

    #
    # -- Generate the document collection
    #
    document_collection = DocumentCollection(setup, bundle)
    document_collection.set_collection_vid()

    #
    # -- Generation of spiceds document
    #
    if setup.pds_version == '4':

        spiceds = SpicedsProduct(setup, document_collection)

        #
        # -- If the spiceds document is generated then the document
        #    collection needs to be updated.
        #
        if spiceds.generated:
            document_collection.add(spiceds)
    
            #
            # -- Generate the documents inventory.
            #
            document_collection.set_collection_vid()
            document_collection_inventory = InventoryProduct(setup,
                                                document_collection)
            document_collection.add(document_collection_inventory)

        #
        # Add spice_kernel Collection to the Bundle. 
        # Note that the collections are provided in a given order.
        #
        bundle.add(spice_kernels_collection)

        #
        # -- Generate the miscellaneous collection. The checksum product
        #    is initialised in such a way that its name can be obtained.
        #
        # -- The first thing that is checked is whether if the current
        #    Bundle has checksums, if so, all the checksums are generated, 
        #    including the corresponding miscellaneous collection inventories 
        #    and labels.
        #
        if setup.increment:
            checksum_dir = setup.final_directory + \
                       f'/{setup.mission_acronym}_spice/miscellaneous/checksum'
            if not isdir(checksum_dir):
                for release in bundle.history.items():
                    release_checksum = ChecksumProduct(setup, 
                                                   miscellaneous_collection)
                    release_checksum.generate(history=release)

                    #
                    # Initialise a miscellaneous collection for this previous
                    # release
                    #
                    release_miscellaneous_collection = \
                        MiscellaneousCollection(setup, bundle, list)
                    
                    #
                    # Add the checksum at the release miscellaneous collection
                    # to generate the adequate inventory file and add it to 
                    # the current miscellaneous collection for it to be 
                    # present at the checksum.
                    #
                    release_miscellaneous_collection.add(release_checksum)
                    
                    miscellaneous_collection.add(release_checksum)

                    release_miscellaneous_collection.set_collection_vid()
                    release_miscellaneous_collection_inventory = \
                        InventoryProduct(setup, 
                                         release_miscellaneous_collection)
                    
                    release_miscellaneous_collection.add(
                        release_miscellaneous_collection_inventory)
                    miscellaneous_collection.add(
                        release_miscellaneous_collection_inventory)

                    #
                    # Add release miscellaneous collection
                    #
                    bundle.add(release_miscellaneous_collection)
                    
                    
            #
            # set miscellaneous collection VID.
            #
            miscellaneous_collection.set_collection_vid()

        #
        # Add miscellaneous collection and document collection
        #
        bundle.add(miscellaneous_collection)
        bundle.add(document_collection)

        
        #
        # From here on now, the checksum and the miscellaneous collection 
        # for the current release are generated.
        #
        # The miscellaneous collection is the one to be guaranteed to be
        # updated.
        #
        checksum = ChecksumProduct(setup, miscellaneous_collection)

        #
        # Before adding the checksum to the current collection
        # we need to specify that is not a new product.
        #
        for product in miscellaneous_collection.product:
            if type(product) == ChecksumProduct:
                product.new_product = False
        
        miscellaneous_collection.add(checksum)
        miscellaneous_collection.set_collection_vid()

        checksum.set_coverage()
        miscellaneous_collection_inventory = InventoryProduct(setup,
                                                miscellaneous_collection)
        miscellaneous_collection.add(miscellaneous_collection_inventory)
    


        #
        # -- Generate bundle label and if necessary readme file.
        #
        bundle.write_readme()

        #
        # -- Generate the checksum product a posteriori in such a way
        #    that the miscellaneous collection inventory includes the
        #    chekcsum and the checksum includes the md5 hash of the
        #    miscellaneous collection inventory.
        #
        checksum.generate()
        miscellaneous_collection.add(checksum)

    elif setup.pds_version == '3':
        pass

    #
    # -- List the files present in the staging area
    #
    bundle.files_in_staging()

    #
    # -- Stop the pipeline if you do not want to move the files from the
    #    staging area. Note that the complete list and the index file
    #    will not be generated.
    #
    if setup.faucet == 'staging':
        log.stop()
        return

    #
    # -- Generate index files, this includes generating the complete
    #    kernel list.
    #
    # OnlyFor PDS3
    # list.write_complete_list()
    # spice_kernels_collection_inventory.write_index()

    #
    # -- Copy files to final area.
    #
    bundle.copy_to_final()

    #
    # -- Stop the pipeline if you do not want to write checksums and
    #    validate the bundle.
    #
    if setup.faucet == 'final':
        log.stop()
        return

    #
    # -- Make sure directory and file permissions are correct.
    #
    
    #
    # -- Validate meta-kernel(s)
    #
    for kernel in spice_kernels_collection.product:
        if type(kernel) == MetaKernelProduct:
            kernel.validate()

    #
    # -- Validate checksum files against the updated bundle history.
    #
    bundle.validate_history()
    
    log.stop()

    return None


if __name__ == '__main__':
    main()
